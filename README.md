# Описание Remove Duplicates from Sorted Array

Задача с LeetCode ([ссылка](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)).

## Дано:
- целочисленный массив `nums`, отсортированный в неубывающем порядке. 

## Задача:
- Удалите дубликаты на месте так, чтобы каждый уникальный элемент встречался только один раз. 
- Относительный порядок элементов должен остаться прежним.
- Затем верните количество уникальных элементов в `nums`.

Пусть количество уникальных элементов в `nums` равно `k`. Чтобы решение было принято, необходимо выполнить следующее:

- Изменить массив `nums` таким образом, чтобы первые `k` элементов содержали уникальные элементы в том порядке, в котором они изначально находились в `nums`. Остальные элементы `nums` не важны, как и итоговый размер массива.
- Вернуть значение `k`.

## Проверка решения судьёй

Судья проверит ваше решение с помощью следующего кода:

```python
nums = [...]           # Входной массив
expected_nums = [...]  # Ожидаемый ответ правильной длины

k = remove_duplicates(nums)  # Вызов вашей реализации

assert k == len(expected_nums), f"Ожидаемая длина: {len(expected_nums)}, получена: {k}"

for i in range(k):
    assert nums[i] == expected_nums[i], f"Элемент под индексом {i} не совпадает: {nums[i]} != {expected_nums[i]}"

print("Все проверки пройдены! Решение принято.")
```

Если все проверки пройдут успешно, ваше решение будет принято.

### Пример 1:

**Ввод:** `nums = [1,1,2]`
**Вывод:** `2`, `nums = [1,2,_]`
**Пояснение:** Ваша функция должна вернуть `k = 2`, при этом первые два элемента `nums` должны быть `1` и `2` соответственно.  
То, что остаётся за пределами `k`, не имеет значения (поэтому на этих позициях указаны символы подчёркивания).

### Пример 2:

**Ввод:** `nums = [0,0,1,1,1,2,2,3,3,4]`
**Вывод:** `5`, `nums = [0,1,2,3,4,_,_,_,_,_]`
**Пояснение:** Ваша функция должна вернуть `k = 5`, при этом первые пять элементов `nums` должны быть `0, 1, 2, 3, 4` соответственно.  
То, что остаётся за пределами `k`, не важно (поэтому остальные позиции заполнены подчёркиваниями).

# Ограничения

* `1 <= nums.length <= 3 * 10^4`
* `-100 <= nums[i] <= 100`
* Массив `nums` отсортирован в неубывающем порядке.

## Подходы к решению

### Два указателя (оптимальное решение)

Решение использует **in-place подход**:

Два указателя паттерн `два указателя`, случай `Паттерн read-write pointer`(Удалении дубликатов):
1. Читающий указатель (`read`) — движется от начала к концу массива.
2. Пишущий указатель (`write`) — указывает, куда класть "хорошие" элементы без дублей.

Они движутся независимо:
* `read` всегда увеличивается на 1 на каждой итерации.
* `write` увеличивается только когда nums[read] != nums[write].
* в `write` позицию записываем все значения без дублей.

`write` указывает на последний уникальный элемент, поэтому `write + 1` даст количество уникальных элементов.

Это классический, эффективный и элегантный подход к обработке массивов in-place.

- **Преимущества**:
  - Сохраняет относительный порядок элементов
  - Не требует дополнительной памяти
  - Эффективен для больших массивов (до 3·10⁴ элементов)

### Нюансы реализации
- **Ранний выход** для массивов длиной ≤ 1 ускоряет обработку тривиальных случаев
- **Проверка на равенство** `nums[read] != nums[write]` эффективно определяет уникальные элементы благодаря сортировке
- **Крайние случаи** (пустой массив, все элементы одинаковые) обрабатываются корректно
- **Оптимизация присваивания**: При отсутствии дубликатов можно избежать лишних операций копирования