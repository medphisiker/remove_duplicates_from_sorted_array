# Описание Remove Duplicates from Sorted Array

Задача с LeetCode ([ссылка](https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150)).

Дан целочисленный массив `nums`, отсортированный в неубывающем порядке. Удалите дубликаты на месте так, чтобы каждый уникальный элемент встречался только один раз. Относительный порядок элементов должен остаться прежним. Затем верните количество уникальных элементов в `nums`.

Пусть количество уникальных элементов в `nums` равно `k`. Чтобы решение было принято, необходимо выполнить следующее:

- Изменить массив `nums` таким образом, чтобы первые `k` элементов содержали уникальные элементы в том порядке, в котором они изначально находились в `nums`. Остальные элементы `nums` не важны, как и итоговый размер массива.
- Вернуть значение `k`.

## Проверка решения судьёй

Судья проверит ваше решение с помощью следующего кода:

```python
nums = [...]           # Входной массив
expected_nums = [...]  # Ожидаемый ответ правильной длины

k = remove_duplicates(nums)  # Вызов вашей реализации

assert k == len(expected_nums), f"Ожидаемая длина: {len(expected_nums)}, получена: {k}"

for i in range(k):
    assert nums[i] == expected_nums[i], f"Элемент под индексом {i} не совпадает: {nums[i]} != {expected_nums[i]}"

print("Все проверки пройдены! Решение принято.")
```

Если все проверки пройдут успешно, ваше решение будет принято.

### Пример 1:

**Ввод:** `nums = [1,1,2]`  
**Вывод:** `2`, `nums = [1,2,_]`  
**Пояснение:** Ваша функция должна вернуть `k = 2`, при этом первые два элемента `nums` должны быть `1` и `2` соответственно.  
То, что остаётся за пределами `k`, не имеет значения (поэтому на этих позициях указаны символы подчёркивания).

### Пример 2:

**Ввод:** `nums = [0,0,1,1,1,2,2,3,3,4]`  
**Вывод:** `5`, `nums = [0,1,2,3,4,_,_,_,_,_]`  
**Пояснение:** Ваша функция должна вернуть `k = 5`, при этом первые пять элементов `nums` должны быть `0, 1, 2, 3, 4` соответственно.  
То, что остаётся за пределами `k`, не важно (поэтому остальные позиции заполнены подчёркиваниями).

# Ограничения

* 1 <= nums.length <= 3 * 104
* -100 <= nums[i] <= 100
* nums is sorted in non-decreasing order.